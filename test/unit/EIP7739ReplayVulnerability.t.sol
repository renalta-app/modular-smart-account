// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {ModularAccountTestBase} from "../helpers/TestBase.sol";
import {EIP7739Helpers} from "../helpers/EIP7739Helpers.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {ModularSmartAccount} from "../../contracts/accounts/ModularSmartAccount.sol";
import {IEntryPoint} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

/// @title EIP7739ReplayVulnerabilityTest
/// @notice Demonstrates the signature replay vulnerability that EIP-7739 solves
///
/// THE PROBLEM:
/// When a single EOA owns multiple smart accounts, the same ERC-1271 signature can be
/// exploited across different accounts through replay attacks. This is because standard
/// ERC-1271 validation doesn't bind the signature to the specific smart account address
/// or chain ID in the validation logic.
///
/// ATTACK SCENARIO:
/// 1. Alice owns two smart accounts (accountA and accountB) controlled by the same EOA
/// 2. Alice signs a message "Transfer 100 USDC" using accountA
/// 3. Attacker captures the signature
/// 4. Attacker replays the same signature on accountB, which also validates successfully
/// 5. Result: Alice loses 100 USDC from BOTH accounts instead of just one
///
/// CROSS-CHAIN SCENARIO:
/// 1. Alice signs a message to approve a transaction on Mainnet
/// 2. Her smart account exists at the same address on Base
/// 3. Attacker replays the signature on Base, getting unauthorized approval
///
/// EIP-7739 SOLUTION:
/// EIP-7739 implements defensive rehashing that incorporates:
/// - The smart account's address
/// - The chain ID
/// - The domain separator
/// This makes each signature unique to a specific account on a specific chain.
contract EIP7739ReplayVulnerabilityTest is ModularAccountTestBase {
    using MessageHashUtils for bytes32;
    using EIP7739Helpers for *;

    IEntryPoint public entryPoint = IEntryPoint(ENTRYPOINT_V08);
    uint256 public chainId;

    function setUp() public {
        chainId = block.chainid;
    }

    function createAccount(address owner) internal returns (ModularSmartAccount) {
        ModularSmartAccount implementation = new ModularSmartAccount(entryPoint);
        bytes memory initData = abi.encodeWithSignature("initialize(address)", owner);
        ERC1967Proxy proxy = new ERC1967Proxy(address(implementation), initData);
        return ModularSmartAccount(payable(address(proxy)));
    }

    /// @notice TEST 1: Signature replay protection across multiple accounts
    /// This test verifies that a signature created for accountA does NOT validate for accountB
    /// even though both accounts have the same owner.
    function test_rejectsSignatureReplayAcrossMultipleAccounts() public {
        (address owner, uint256 ownerKey) = createAccountOwner();
        fund(owner, 10 ether);

        ModularSmartAccount accountA = createAccount(owner);
        ModularSmartAccount accountB = createAccount(owner);

        assertEq(accountA.owner(), owner);
        assertEq(accountB.owner(), owner);
        assertTrue(address(accountA) != address(accountB), "Accounts must be different");

        bytes32 messageHash = keccak256("Approve spending 100 USDC from my account");

        bytes32 accountADomain = EIP7739Helpers.computeDomainSeparator(address(accountA), chainId);
        bytes memory signature = EIP7739Helpers.signPersonalSign(vm, ownerKey, messageHash, accountADomain);

        bytes4 resultA = accountA.isValidSignature(messageHash, signature);
        assertEq(resultA, ERC1271_MAGIC_VALUE, "Signature should be valid for accountA");

        bytes4 resultB = accountB.isValidSignature(messageHash, signature);

        assertEq(resultB, bytes4(0xffffffff), "EIP-7739: Signature for accountA should NOT be valid for accountB");
    }

    /// @notice TEST 2: Cross-chain signature replay protection
    /// This test verifies that a signature valid on one chain does NOT validate on another chain.
    function test_rejectsSignatureReplayCrossChain() public {
        (address owner, uint256 ownerKey) = createAccountOwner();
        fund(owner, 10 ether);

        ModularSmartAccount account = createAccount(owner);

        bytes32 messageHash = keccak256("Approve cross-chain transfer");

        bytes32 accountDomain = EIP7739Helpers.computeDomainSeparator(address(account), chainId);
        bytes memory signature = EIP7739Helpers.signPersonalSign(vm, ownerKey, messageHash, accountDomain);

        bytes4 resultOriginalChain = account.isValidSignature(messageHash, signature);
        assertEq(resultOriginalChain, ERC1271_MAGIC_VALUE, "Signature should be valid on original chain");

        uint256 differentChainId = chainId == 8453 ? 1 : 8453;
        vm.chainId(differentChainId);

        bytes4 resultDifferentChain = account.isValidSignature(messageHash, signature);

        assertEq(resultDifferentChain, bytes4(0xffffffff), "EIP-7739: Signature should NOT be valid on different chain");
    }

    /// @notice TEST 3: Complete protection against realistic attack scenario
    /// Verifies that a payment signature for personal account cannot be replayed on business account.
    function test_preventsCompleteAttackScenario() public {
        (address alice, uint256 aliceKey) = createAccountOwner();
        fund(alice, 10 ether);

        ModularSmartAccount personalAccount = createAccount(alice);
        ModularSmartAccount businessAccount = createAccount(alice);

        bytes32 paymentMessage = keccak256(
            abi.encodePacked(
                "ApprovePayment",
                address(0xdead), // merchant address
                uint256(100e6) // 100 USDC
            )
        );

        bytes32 personalDomain = EIP7739Helpers.computeDomainSeparator(address(personalAccount), chainId);
        bytes memory signature = EIP7739Helpers.signPersonalSign(vm, aliceKey, paymentMessage, personalDomain);

        bytes4 personalResult = personalAccount.isValidSignature(paymentMessage, signature);
        assertEq(personalResult, ERC1271_MAGIC_VALUE, "Personal account should validate");

        bytes4 businessResult = businessAccount.isValidSignature(paymentMessage, signature);

        assertEq(
            businessResult,
            bytes4(0xffffffff),
            "EIP-7739: Signature for personal account should NOT validate for business account"
        );
    }

    /// @notice TEST 4: Verifies EIP-7739 magic value for support detection
    /// Tests that contracts can query for EIP-7739 support
    function test_eip7739SupportDetection() public {
        (address owner,) = createAccountOwner();
        ModularSmartAccount account = createAccount(owner);

        // EIP-7739 specifies that contracts should return 0x77390001 for this specific query
        bytes32 magicHash = 0x7739773977397739773977397739773977397739773977397739773977397739;
        bytes memory emptySignature = "";

        bytes4 result = account.isValidSignature(magicHash, emptySignature);

        // Should return 0x77390001 to indicate EIP-7739 support
        // This allows clients to detect EIP-7739 support before using it
        assertEq(result, bytes4(0x77390001), "EIP-7739: Should return magic value 0x77390001 for support detection");
    }
}
